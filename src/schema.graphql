# import UserOrderByInput, SellerOrderByInput, ReviewOrderByInput, ProductOrderByInput, OrderOrderByInput from './generated/prisma.graphql'

type Query {
  users(
    query: String
    first: Int
    skip: Int
    after: String
    orderBy: UserOrderByInput
  ): [User!]!
  sellers(
    query: String
    first: Int
    skip: Int
    after: String
    orderBy: SellerOrderByInput
  ): [Seller!]!
  products(
    query: String
    first: Int
    skip: Int
    after: String
    orderBy: ProductOrderByInput
  ): [Product!]!
  meUser: User!
  meSeller: Seller!
  reviews(
    first: Int
    skip: Int
    after: String
    orderBy: ReviewOrderByInput
  ): [Review!]!
  myReviews: [Review!]!
}

type Mutation {
  createUser(data: CreateUserInput!): UserAuthPayLoad!
  loginUser(data: LoginUserInput!): UserAuthPayLoad!
  updateUser(data: UpdateUserInput!): User!
  deleteUser: User!
  createSeller(data: CreateSellerInput!): SellerAuthPayLoad!
  loginSeller(data: LoginUserInput!): SellerAuthPayLoad!
  updateSeller(data: UpdateSellerInput!): Seller!
  deleteSeller: Seller!
  createProduct(data: CreateProductInput!): Product!
  updateProduct(id: ID!, data: UpdateProductInput!): Product!
  deleteProduct(id: ID!): Product!
  createReview(data: CreateReviewInput!): Review!
  updateReview(id: ID!, data: UpdateReviewInput!): Review!
  deleteReview(id: ID!): Review!
  createOrder(data: CreateOrderInput!): Order!
}

enum UserType {
  BUYER
}

enum SellerType {
  SELLER
}

type User {
  id: ID!
  name: String!
  #  email will have to be changed this to nullable because email wont be returned to every query
  email: String
  password: String!
  age: Int
  orders: [Order!]!
  reviews: [Review!]!
  type: UserType!
}

input CreateUserInput {
  name: String!
  email: String!
  password: String!
  age: Int
  type: UserType!
}

input LoginUserInput {
  email: String!
  password: String!
}

type UserAuthPayLoad {
  token: String!
  user: User!
}

input UpdateUserInput {
  name: String
  email: String
  password: String
  age: Int
}

type Seller {
  id: ID!
  name: String!
  #  ???? email will have to be changed this to nullable because email wont be returned to every query
  email: String
  password: String!
  products: [Product!]!
  orders: [Order!]!
  type: SellerType!
}

input CreateSellerInput {
  name: String!
  email: String!
  password: String!
  type: SellerType!
}

input LoginSellerInput {
  email: String!
  password: String!
}

type SellerAuthPayLoad {
  token: String!
  seller: Seller!
}

input UpdateSellerInput {
  name: String
  email: String
  password: String
}

type Product {
  id: ID!
  name: String!
  department: String!
  price: Float!
  count: Int!
  rating: Float!
  seller: Seller!
  reviews: [Review!]!
  orders: [Order!]!
}

input CreateProductInput {
  name: String!
  department: String!
  price: Float!
  count: Int!
  #   seller: ID!
}

input UpdateProductInput {
  name: String
  department: String
  price: Float
  count: Int
}

type Order {
  id: ID!
  products: [Product!]!
  total: Float!
  user: User!
}

input CreateOrderInput {
  products: [ID!]!
  # total: Float! will be calculated in mutation
  # user: User! user will have to be logged it, we get the id from getUser.js
}

type Review {
  id: ID!
  text: String!
  rating: Int!
  user: User!
  product: Product!
  published: Boolean!
}

input CreateReviewInput {
  text: String!
  rating: Int!
  product: ID!
  published: Boolean!
}
input UpdateReviewInput {
  text: String
  rating: Int
  published: Boolean
}

